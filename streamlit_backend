import os
import pandas as pd
import plotly.graph_objs as go
from fastapi import FastAPI, UploadFile, File, Form
from fastapi.responses import JSONResponse
from PyPDF2 import PdfReader
from dotenv import load_dotenv
from groq import Groq
from fastapi.middleware.cors import CORSMiddleware
import google.generativeai as genai
import json

load_dotenv()

GROQ_API_KEY = os.getenv("GROQ_API_KEY")
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")

genai.configure(api_key=GOOGLE_API_KEY)

DEFAULT_CHART_EXAMPLES = """
Here are examples of different Plotly charts:

1. Bar Chart:
```python
fig = go.Figure(data=[go.Bar(x=df['x_column'], y=df['y_column'])])
fig.update_layout(title='Bar Chart Example', xaxis_title='X-Axis', yaxis_title='Y-Axis')
```

2. Line Chart:
```python
fig = go.Figure(data=[go.Scatter(x=df['x_column'], y=df['y_column'], mode='lines')])
fig.update_layout(title='Line Chart Example', xaxis_title='X-Axis', yaxis_title='Y-Axis')
```

3. Scatter Plot:
```python
fig = go.Figure(data=[go.Scatter(x=df['x_column'], y=df['y_column'], mode='markers')])
fig.update_layout(title='Scatter Plot Example', xaxis_title='X-Axis', yaxis_title='Y-Axis')
```

4. Pie Chart:
```python
fig = go.Figure(data=[go.Pie(labels=df['label_column'], values=df['value_column'])])
fig.update_layout(title='Pie Chart Example')
```

5. Heatmap:
```python
fig = go.Figure(data=[go.Heatmap(z=df['z_column'], x=df['x_column'], y=df['y_column'])])
fig.update_layout(title='Heatmap Example', xaxis_title='X-Axis', yaxis_title='Y-Axis')
```
"""

# Initialize FastAPI app
app = FastAPI()

# Add CORS middleware to the app
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Replace "*" with your frontend's URL for better security
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)



def initialize_google_model(model_name: str):
    """Initialize the specified Google Generative AI model and start a chat session."""
    try:
        # Define the generation configuration
        generation_config = {
            "temperature": 1,
            "top_p": 0.95,
            "top_k": 40,
            "max_output_tokens": 8192,
            "response_mime_type": "text/plain",
        }

        # Create the model instance
        model = genai.GenerativeModel(
            model_name=model_name,
            generation_config=generation_config,
        )

        # Start a chat session with an empty history
        chat_session = model.start_chat(history=[])

        return chat_session
    except Exception as e:
        raise RuntimeError(f"Error initializing Google Generative AI model: {str(e)}")


# Initialize the specified LLM model
def initialize_model(model_name: str, source: str):
    if source in ["Hugging Face","Meta","Mistral AI"]:
        client = Groq(api_key=GROQ_API_KEY)
        return client
    elif source == "Gemini":
        return initialize_google_model(model_name)
    else:
        raise ValueError("Unsupported model selected")

# Analyze dataset and recommend visualization using LLM
def analyze_and_recommend(data: pd.DataFrame, model_instance, model_name) -> dict:
    try:
        columns = ", ".join(data.columns)
        prompt = f"""
        You are a highly skilled data visualization assistant. Your task is to analyze the given dataset and determine the most appropriate Plotly chart types for visualizing the data effectively.

        Dataset Columns: {columns}

        ## **Guidelines for Visualization Selection**
        - **Choose the most appropriate chart types** based on the data distribution and relationships (e.g., bar chart for categorical comparisons, scatter plot for numerical correlations, pie chart for proportions, etc.).
        - **Only include valid column mappings**:
        - Ensure that `x_axis` and `y_axis` are **never null** for charts that require both axes (e.g., bar, line, scatter, heatmap).
        - Ensure that `label_column` and `value_column` are **never null** for pie charts.
        - **Ensure meaningful axis selections**:
        - Do **not** use non-numeric columns for `y_axis` unless appropriate (e.g., counts, aggregations).
        - Avoid using high-cardinality categorical columns as `x_axis` unless meaningful.
        - **If a chart type is not appropriate, DO NOT include it.**
        - Do not include charts that lack the required numerical or categorical relationships.
        - Do not suggest heatmaps or scatter plots if they do not have valid numeric or categorical pairings.
        - If a chart field is missing or not meaningful, **restructure the response** instead of leaving fields `null`.

        Guidelines:
        - Examine the column names and infer their likely data types and relationships.
        - Suggest the best type of chart for visualizing the data (e.g., bar chart, line chart, scatter plot, pie chart, heatmap).
        - For charts requiring axes (e.g., bar, scatter, line), specify the most appropriate X-axis and Y-axis columns .
        - Ensure for which you are recommending the chart type and like wise give the appropriate X-axis and Y-axis ensure you didn't miss anything.
        - Suggest all relevant chart types based on the dataset.
        - Ensure that for each chart type, all required axes and values are specified.
        - If multiple charts can be useful, suggest all relevant ones.
        - Ensure completeness and correctness of the recommendations before responding.
        - Provide a clear explanation (rationale) for why this chart type is the best choice.
        - Suggest any additional columns that can enhance the visualization (e.g., color, size, or labels for better insights).
        - Don't give me any resonings only the give JSON Format.
         Respond strictly in **valid JSON format** as a **single list** of objects.
        - **DO NOT return multiple separate JSON objects.** Instead, return a single JSON array like this:
        - Don't specify json in the response.
        - Retry up to 3 times in case of missing fields before reporting an error.

        Examples of visualizations include:
        {DEFAULT_CHART_EXAMPLES}

        Ensure your response adheres to the following JSON structure strictly:
        ```
        {{
            "chart_type": "string",        // The recommended chart type (e.g., "bar", "line", "scatter", etc.)
            "x_axis": "string or null",    // Column name for the X-axis (or null if not applicable)
            "y_axis": "string or null",    // Column name for the Y-axis (or null if not applicable)
            "label_column": "string or null", // Column name for labels (or null if not applicable)
            "value_column": "string or null", // Column name for values (or null if not applicable)
            "rationale": "string"          // Explanation of why this chart type is recommended
        }}
        """

        
        completion = model_instance.chat.completions.create(
            model=model_name,
            messages=[{"role": "system", "content": prompt}],
            temperature=1,
            max_completion_tokens=1024
        )

        response_content = completion.choices[0].message.content
        print(response_content)
        recommendation = json.loads(response_content)

        if not isinstance(recommendation, list):
            raise ValueError("Response should be a list of chart recommendations")

        required_keys = {"chart_type", "rationale"}

        optional_keys = {"x_axis", "y_axis", "label_column", "value_column"}
        
        validated_recommendations = []
        for idx, recommendation in enumerate(recommendation):
            # Ensure all required keys are present
            if not required_keys.issubset(recommendation.keys()):
                missing = required_keys - recommendation.keys()
                raise ValueError(f"Entry {idx} missing required keys: {', '.join(missing)}")

            # Ensure optional keys are either present or null
            for key in optional_keys:
                if key not in recommendation:
                    recommendation[key] = None  # Set missing optional keys to null

            validated_recommendations.append(recommendation)

        return validated_recommendations

    except json.JSONDecodeError as e:
        raise RuntimeError(f"Invalid JSON response: {e}")
    except Exception as e:
        raise RuntimeError(f"Error analyzing and recommending chart: {e}")

# Generate Plotly chart based on recommendation
def generate_plotly_chart(data: pd.DataFrame, chart_recommendation: dict) -> dict:
    try:
        chart_type = chart_recommendation.get("chart_type")
        x_axis = chart_recommendation.get("x_axis")
        y_axis = chart_recommendation.get("y_axis")
        label_column = chart_recommendation.get("label_column")
        value_column = chart_recommendation.get("value_column")
        rationale = chart_recommendation.get("rationale")

        # Handle "null" strings
        if x_axis == "null":
            x_axis = None
        if y_axis == "null":
            y_axis = None
        if label_column == "null":
            label_column = None
        if value_column == "null":
            value_column = None

        # Validate required fields
        if not chart_type:
            raise ValueError("No chart type recommended.")

        if chart_type in ["bar", "line", "scatter", "heatmap"] and (not x_axis or not y_axis):
            raise ValueError(f"Both x_axis and y_axis must be specified for a {chart_type} chart.")

        if chart_type == "pie" and (not label_column or not value_column):
            raise ValueError("Both label_column and value_column must be specified for a pie chart.")

        # Generate the appropriate chart
        if chart_type == "bar":
            fig = go.Figure(data=[go.Bar(x=data[x_axis], y=data[y_axis])])

        elif chart_type == "line":
            fig = go.Figure(data=[go.Scatter(x=data[x_axis], y=data[y_axis], mode="lines")])

        elif chart_type == "scatter":
            fig = go.Figure(data=[go.Scatter(x=data[x_axis], y=data[y_axis], mode="markers")])

        elif chart_type == "pie":
            fig = go.Figure(data=[go.Pie(labels=data[label_column], values=data[value_column])])

        elif chart_type == "heatmap":
            if not x_axis or not y_axis:
                raise ValueError("Both x_axis and y_axis must be specified for a heatmap.")
            z_values = data.groupby([x_axis, y_axis]).size().unstack(fill_value=0)
            fig = go.Figure(data=[go.Heatmap(z=z_values.values, x=z_values.columns, y=z_values.index)])

        else:
            raise ValueError(f"Unsupported chart type: {chart_type}")

        # Update layout
        fig.update_layout(
            title=f"{chart_type.capitalize()} Visualization",
            xaxis_title=x_axis.capitalize() if x_axis else None,
            yaxis_title=y_axis.capitalize() if y_axis else None,
            template="plotly_white"
        )

        return {
            "recommendation": chart_recommendation,
            "chart": fig.to_json(),
        }

    except KeyError as e:
        raise RuntimeError(f"Missing key in data or recommendation: {e}")
    except Exception as e:
        raise RuntimeError(f"Error generating Plotly chart: {e}")


# FastAPI endpoint to process uploaded files
@app.post("/process-file/")
async def process_file(file: UploadFile = File(...), model_name: str = Form(...), source: str = Form(...)):
    try:
        print(f"Model Name: {model_name}, Source: {source}")
        print(f"File Content Type: {file.content_type}")

        # Handle PDF files
        if file.content_type == "application/pdf":
            pdf_reader = PdfReader(file.file)
            text = "\n".join([page.extract_text() for page in pdf_reader.pages if page.extract_text()])
            return {"success": True, "type": "pdf", "content": text}

        # Handle CSV files
        elif file.content_type == "text/csv":
            data = pd.read_csv(file.file)
            if data.empty:
                raise ValueError("Uploaded CSV file is empty.")

            # Initialize the model
            model = initialize_model(model_name, source)

            # Get chart recommendations
            recommendations = analyze_and_recommend(data, model, model_name)

            # Generate charts for each recommendation
            charts = []
            for recommendation in recommendations:
                try:
                    chart_json = generate_plotly_chart(data, recommendation)
                    charts.append(chart_json)
                except Exception as e:
                    print(f"Error generating chart for recommendation: {recommendation}. Error: {e}")
                    continue  # Skip this recommendation and continue with the next one

            return {
                "success": True,
                "recommendations": recommendations,
                "charts": charts
            }

        # Handle unsupported file types
        else:
            return JSONResponse(content={"error": "Unsupported file type"}, status_code=400)

    except Exception as e:
        print(f"Error: {e}")
        return JSONResponse(content={"error": str(e)}, status_code=500)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)